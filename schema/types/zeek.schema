type zeek.conn_id = record {
  orig_h: ip,
  orig_p: port,
  resp_h: ip,
  resp_p: port,
}

type zeek.capture_loss = record {
  ts: timestamp,
  ts_delta: duration,
  peer: string,
  gaps: uint64,
  acks: uint64,
  percent_lost: double,
  _write_ts: time,
}

type zeek.conn = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  proto: string,
  service: string,
  duration: duration,
  orig_bytes: uint64,
  resp_bytes: uint64,
  conn_state: string,
  local_orig: bool,
  local_resp: bool,
  missed_bytes: uint64,
  history: string,
  orig_pkts: uint64,
  orig_ip_bytes: uint64,
  resp_pkts: uint64,
  resp_ip_bytes: uint64,
  tunnel_parents: list<string>,
  community_id: string,
  _write_ts: time,
}

type zeek.dce_rpc = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  rtt: duration,
  named_pipe: string,
  endpoint: string,
  operation: string,
  _write_ts: time,
}

type zeek.dhcp = record {
  ts: timestamp,
  uids: list<string>,
  client_addr: ip,
  server_addr: ip,
  mac: string,
  host_name: string,
  client_fqdn: string,
  domain: string,
  requested_addr: ip,
  assigned_addr: ip,
  lease_time: duration,
  client_message: string,
  server_message: string,
  msg_types: list<string>,
  duration: duration,
  trans_id: uint64,
  _write_ts: time,
}

type zeek.dnp3 = record {
  ts: time,
  uid: string #index=hash,
  id: zeek.conn_id,
  fc_reply: string,
  iin: uint64,
  _write_ts: time,
}

type zeek.dns = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  proto: string,
  trans_id: uint64,
  rtt: duration,
  query: string,
  qclass: uint64,
  qclass_name: string,
  qtype: uint64,
  qtype_name: string,
  rcode: uint64,
  rcode_name: string,
  AA: bool,
  TC: bool,
  RD: bool,
  RA: bool,
  Z: uint64,
  answers: list<string>,
  TTLs: list<duration>,
  rejected: bool,
  _write_ts: time,
}

type zeek.dpd = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  proto: string,
  analyzer: string,
  failure_reason: string,
  _write_ts: time,
}

type zeek.files = record {
  ts: timestamp,
  fuid: string,
  tx_hosts: list<ip>,
  rx_hosts: list<ip>,
  conn_uids: list<string>,
  source: string,
  depth: uint64,
  analyzers: list<string>,
  mime_type: string,
  filename: string,
  duration: duration,
  local_orig: bool,
  is_orig: bool,
  seen_bytes: uint64,
  total_bytes: uint64,
  missing_bytes: uint64,
  overflow_bytes: uint64,
  timedout: bool,
  parent_fuid: string,
  md5: string,
  sha1: string,
  sha256: string,
  extracted: string,
  extracted_cutoff: bool,
  extracted_size: uint64,
  _write_ts: time,
}

type zeek.ftp = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  user: string,
  password: string,
  command: string,
  arg: string,
  mime_type: string,
  file_size: uint64,
  reply_code: uint64,
  reply_msg: string,
  data_channel: record {
    passive: bool,
    orig_h: ip,
    resp_h: ip,
    resp_p: port,
  },
  fuid: string,
  _write_ts: time,
}

type zeek.http = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  trans_depth: uint64,
  method: string,
  host: string,
  uri: string,
  referrer: string,
  version: string,
  user_agent: string,
  request_body_len: uint64,
  response_body_len: uint64,
  status_code: uint64,
  status_msg: string,
  info_code: uint64,
  info_msg: string,
  tags: list<string>,
  username: string,
  password: string,
  proxied: list<string>,
  orig_fuids: list<string>,
  orig_filenames: list<string>,
  orig_mime_types: list<string>,
  resp_fuids: list<string>,
  resp_filenames: list<string>,
  resp_mime_types: list<string>,
  _write_ts: time,
}

type zeek.intel = record {
  ts: time,
  uid: string #index=hash,
  id: zeek.conn_id,
  seen: record {
    indicator: string,
    indicator_type: string,
    where: string,
  },
  matched: list<string>,
  sources: list<string>,
  _write_ts: time,
}

type zeek.irc = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  nick: string,
  user: string,
  command: string,
  value: string,
  addl: string,
  dcc_file_name: string,
  dcc_file_size: uint64,
  dcc_mime_type: string,
  fuid: string,
  _write_ts: time,
}

type zeek.loaded_scripts = record {
  name: string,
  _write_ts: time,
}

type zeek.notice = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  fuid: string,
  file_mime_type: string,
  file_desc: string,
  proto: string,
  note: string,
  msg: string,
  sub: string,
  src: ip,
  dst: ip,
  p: port,
  n: uint64,
  peer_descr: string,
  actions: list<string>,
  suppress_for: duration,
  dropped: bool,
  remote_location: record {
    country_code: string,
    region: string,
    city: string,
    latitude: double,
    longitude: double,
  },
  _write_ts: time,
}

type zeek.ntlm = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  username: string,
  hostname: string,
  domainname: string,
  server_nb_computer_name: string,
  server_dns_computer_name: string,
  server_tree_name: string,
  success: bool,
  status: string,
  _write_ts: time,
}

type zeek.packet_filter = record {
  ts: timestamp,
  node: string,
  filter: string,
  init: bool,
  success: bool,
  _write_ts: time,
}

type zeek.pe = record {
  ts: timestamp,
  id: string,
  machine: string,
  compile_ts: time,
  os: string,
  subsystem: string,
  is_exe: bool,
  is_64bit: bool,
  uses_aslr: bool,
  uses_dep: bool,
  uses_code_integrity: bool,
  uses_seh: bool,
  has_import_table: bool,
  has_export_table: bool,
  has_cert_table: bool,
  has_debug_data: bool,
  section_names: list<string>,
  _write_ts: time,
}

type zeek.radius = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  username: string,
  result: string,
  _write_ts: time,
}

type zeek.rdp = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  cookie: string,
  result: string,
  security_protocol: string,
  keyboard_layout: string,
  client_build: string,
  client_name: string,
  client_dig_product_id: string,
  desktop_width: uint64,
  desktop_height: uint64,
  requested_color_depth: string,
  cert_type: string,
  cert_count: uint64,
  cert_permanent: bool,
  encryption_level: string,
  encryption_method: string,
  _write_ts: time,
}

type zeek.reporter = record {
  ts: timestamp,
  level: string,
  message: string,
  location: string,
  _write_ts: time,
}

type zeek.sip = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  trans_depth: uint64,
  method: string,
  uri: string,
  date: string,
  request_from: string,
  request_to: string,
  response_from: string,
  response_to: string,
  reply_to: string,
  call_id: string,
  seq: string,
  subject: string,
  request_path: list<string>,
  response_path: list<string>,
  user_agent: string,
  status_code: uint64,
  status_msg: string,
  warning: string,
  request_body_len: uint64,
  response_body_len: uint64,
  content_type: string,
  _write_ts: time,
}

type zeek.smb = record {
  ts: time,
  uid: string #index=hash,
  id: zeek.conn_id,
  action: string,
  name: string,
  size: double,
  path: string,
  service: string,
  share_type: string,
  _write_ts: time,
}

type zeek.smtp = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  trans_depth: uint64,
  helo: string,
  mailfrom: string,
  rcptto: list<string>,
  date: string,
  from: string,
  to: list<string>,
  cc: list<string>,
  reply_to: string,
  msg_id: string,
  in_reply_to: string,
  subject: string,
  x_originating_ip: ip,
  first_received: string,
  second_received: string,
  last_reply: string,
  path: list<ip>,
  user_agent: string,
  tls: bool,
  fuids: list<string>,
  is_webmail: bool,
  _write_ts: time,
}

type zeek.snmp = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  duration: duration,
  version: string,
  community: string,
  get_requests: uint64,
  get_bulk_requests: uint64,
  get_responses: uint64,
  set_requests: uint64,
  display_string: string,
  up_since: time,
  _write_ts: time,
}

type zeek.software = record {
  ts: time,
  host: ip,
  software_type: string,
  name: string,
  version: record {
    major: uint64,
    minor: double,
  },
  unparsed_version: string,
  _write_ts: time,
}

type zeek.ssh = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  version: uint64,
  auth_success: bool,
  auth_attempts: uint64,
  direction: string,
  client: string,
  server: string,
  cipher_alg: string,
  mac_alg: string,
  compression_alg: string,
  kex_alg: string,
  host_key_alg: string,
  host_key: string,
  _write_ts: time,
}

type zeek.ssl = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  version: string,
  cipher: string,
  curve: string,
  server_name: string,
  resumed: bool,
  last_alert: string,
  next_protocol: string,
  established: bool,
  cert_chain_fuids: list<string>,
  client_cert_chain_fuids: list<string>,
  subject: string,
  issuer: string,
  client_subject: string,
  client_issuer: string,
  validation_status: string,
  ja3: string,
  _write_ts: time,
}

type zeek.stats = record {
  ts: timestamp,
  peer: string,
  mem: uint64,
  pkts_proc: uint64,
  bytes_recv: uint64,
  pkts_dropped: uint64,
  pkts_link: uint64,
  pkt_lag: duration,
  events_proc: uint64,
  events_queued: uint64,
  active_tcp_conns: uint64,
  active_udp_conns: uint64,
  active_icmp_conns: uint64,
  tcp_conns: uint64,
  udp_conns: uint64,
  icmp_conns: uint64,
  timers: uint64,
  active_timers: uint64,
  files: uint64,
  active_files: uint64,
  dns_requests: uint64,
  active_dns_requests: uint64,
  reassem_tcp_size: uint64,
  reassem_file_size: uint64,
  reassem_frag_size: uint64,
  reassem_unknown_size: uint64,
  _write_ts: time,
}

type zeek.tunnel = record {
  ts: time,
  uid: string #index=hash,
  id: zeek.conn_id,
  tunnel_type: string,
  action: string,
  _write_ts: time,
}

type zeek.weird = record {
  ts: timestamp,
  uid: string #index=hash,
  id: zeek.conn_id,
  name: string,
  addl: string,
  notice: bool,
  peer: string,
  _write_ts: time,
}

type zeek.x509 = record {
  ts: timestamp,
  id: string,
  certificate: record {
    version: uint64,
    serial: string,
    subject: string,
    issuer: string,
    not_valid_before: time,
    not_valid_after: time,
    key_alg: string,
    sig_alg: string,
    key_type: string,
    key_length: uint64,
    exponent: string,
    curve: string,
  },
  san: record {
    dns: list<string>,
    uri: list<string>,
    email: list<string>,
    ip: list<ip>,
  },
  basic_constraints: record {
    ca: bool,
    path_len: uint64,
  },
  _write_ts: time,
}
