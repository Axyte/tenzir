"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3380],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=l(n),m=r,h=c["".concat(p,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2486:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={},s="Query",i={unversionedId:"use/query/README",id:"use/query/README",title:"Query",description:"Querying data from VAST (aka exporting) involves spinning up a VAST client",source:"@site/docs/use/query/README.md",sourceDirName:"use/query",slug:"/use/query/",permalink:"/docs/use/query/",draft:!1,editUrl:"https://github.com/tenzir/vast/tree/master/web/docs/use/query/README.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Ingest",permalink:"/docs/use/ingest/"},next:{title:"Transform",permalink:"/docs/use/transform/"}},p={},l=[{value:"Decide what to query",id:"decide-what-to-query",level:2},{value:"Write a query expression",id:"write-a-query-expression",level:2},{value:"Choose an export format",id:"choose-an-export-format",level:2}],u={toc:l},c="wrapper";function d(e){let{components:t,...o}=e;return(0,r.kt)(c,(0,a.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"query"},"Query"),(0,r.kt)("p",null,"Querying data from VAST (aka ",(0,r.kt)("em",{parentName:"p"},"exporting"),") involves spinning up a VAST client\nthat executes a query expression. In the following, we assume that you ",(0,r.kt)("a",{parentName:"p",href:"/docs/use/run"},"set up a\nserver")," listening at ",(0,r.kt)("inlineCode",{parentName:"p"},"localhost:42000"),"."),(0,r.kt)("p",null,"To run a query, you need to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"know what to look for"),(0,r.kt)("li",{parentName:"ol"},"express what you want"),(0,r.kt)("li",{parentName:"ol"},"decide in what format to show the result")),(0,r.kt)("p",null,"Let's go through each of these steps."),(0,r.kt)("h2",{id:"decide-what-to-query"},"Decide what to query"),(0,r.kt)("p",null,"To figure out what you can query, VAST offers\n",(0,r.kt)("a",{parentName:"p",href:"/docs/use/introspect"},"introspection")," via the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," command."),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"show schemas")," to display the schema of all types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"vast show schemas --yaml\n")),(0,r.kt)("p",null,"In case you ingested ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/suricata"},"Suricata")," data, this\nmay print:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"- suricata.flow:\n    record:\n      - timestamp:\n          timestamp: time\n      - flow_id:\n          type: uint64\n          attributes:\n            index: hash\n      - pcap_cnt: uint64\n      - vlan:\n          list: uint64\n      - in_iface: string\n      - src_ip: ip\n      - src_port:\n          port: uint64\n      - dest_ip: ip\n      - dest_port:\n          port: uint64\n      - proto: string\n      - event_type: string\n      - community_id:\n          type: string\n          attributes:\n            index: hash\n      - flow:\n          suricata.component.flow:\n            record:\n              - pkts_toserver: uint64\n              - pkts_toclient: uint64\n              - bytes_toserver: uint64\n              - bytes_toclient: uint64\n              - start: time\n              - end: time\n              - age: uint64\n              - state: string\n              - reason: string\n              - alerted: bool\n      - app_proto: string\n- suricata.http:\n    record:\n      - timestamp:\n          timestamp: time\n      - flow_id:\n          type: uint64\n          attributes:\n            index: hash\n      - pcap_cnt: uint64\n      - vlan:\n          list: uint64\n      - in_iface: string\n      - src_ip: ip\n      - src_port:\n          port: uint64\n      - dest_ip: ip\n      - dest_port:\n          port: uint64\n      - proto: string\n      - event_type: string\n      - community_id:\n          type: string\n          attributes:\n            index: hash\n      - http:\n          record:\n            - hostname: string\n            - url: string\n            - http_port:\n                port: uint64\n            - http_user_agent: string\n            - http_content_type: string\n            - http_method: string\n            - http_refer: string\n            - protocol: string\n            - status: uint64\n            - redirect: string\n            - length: uint64\n      - tx_id:\n          type: uint64\n          attributes:\n            index: hash\n")),(0,r.kt)("p",null,"The next section discusses how you can refer to various elements of this type\nschema."),(0,r.kt)("h2",{id:"write-a-query-expression"},"Write a query expression"),(0,r.kt)("p",null,"We designed the ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/query-language"},(0,r.kt)("strong",{parentName:"a"},"VAST")," ",(0,r.kt)("strong",{parentName:"a"},"Q"),"uery ",(0,r.kt)("strong",{parentName:"a"},"L"),"anguage\n(VASTQL)")," to make it easy to reference the data\nschema and put constraints on it. Specifically, VAST's expression language has\nthe concept of\n",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/query-language/expressions#extractors"},"extractors")," that refer\nto various parts of the event structure:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Extractors #width500",src:n(96435).Z+"#gh-light-mode-only",width:"975",height:"622"}),"\n",(0,r.kt)("img",{alt:"Extractors #width500",src:n(50202).Z+"#gh-dark-mode-only",width:"975",height:"622"})),(0,r.kt)("p",null,"For example, you can query the above schemas with a ",(0,r.kt)("em",{parentName:"p"},"meta extractor")," to select a\nspecific set of event types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#type == /suricata.(http|flow)/\n")),(0,r.kt)("p",null,"This predicate restricts a query to the event types ",(0,r.kt)("inlineCode",{parentName:"p"},"suricata.flow")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"suricata.http"),". You can think of the meta extractor as operating on the table\nheader, whereas ",(0,r.kt)("em",{parentName:"p"},"field extractors")," operate on the table body instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'hostname == "evil.com" || dest_ip in 10.0.0.0/8\n')),(0,r.kt)("p",null,"This expression has two predicates with field extractors. The first field\nextractor ",(0,r.kt)("inlineCode",{parentName:"p"},"hostname")," is in fact a suffix of the fully-qualified field\n",(0,r.kt)("inlineCode",{parentName:"p"},"suricata.http.hostname"),". Because it's often inconvenient to write down the\ncomplete field name, you can write just ",(0,r.kt)("inlineCode",{parentName:"p"},"hostname")," instead. Of there exist\nmultiple fields that qualify, VAST builds the logical OR (a ",(0,r.kt)("em",{parentName:"p"},"disjunction"),") of\nall fields. This may unfold as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'suricata.http.hostname == "evil.com" || myevent.hostname == "evil.com" || ...\n')),(0,r.kt)("p",null,'So at the end it\'s up to you: if you want to be fast and can live with\npotentially cross-firing other matches, then you can go with the "short and\nsweet" style of writing your query. If you need exact answers, you can always\nwrite out the entire field.'),(0,r.kt)("p",null,"Looking at the other side of the field name, we have its type. This is where\n",(0,r.kt)("em",{parentName:"p"},"type extractors")," come into play. In you don't know the field name you are\nlooking for, we still want that you can write queries effectively. Taking the\nabove query as an example, you can also write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},':string == "evil.com" || :ip in 10.0.0.0/8\n')),(0,r.kt)("p",null,"In fact, both predicates in this expression are what we call ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/query-language/expressions#value-predicates"},"value\npredicates"),",\nmaking it possible to shorten this expression to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'"evil.com" || 10.0.0.0/8\n')),(0,r.kt)("p",null,"Using type extractors (and thereby value predicates) hinges on having\na powerful type system. If you only have strings and numbers, this is not\nhelping much. VAST's ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/data-model/type-system"},"type system"),"\nsupports ",(0,r.kt)("em",{parentName:"p"},"aliases"),", e.g., you can define an alias called ",(0,r.kt)("inlineCode",{parentName:"p"},"port")," that points to a\n",(0,r.kt)("inlineCode",{parentName:"p"},"uint64"),". Then you'd write a query only over ports:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},":port != 443\n")),(0,r.kt)("p",null,"As above, this predicate would apply to all fields of type ",(0,r.kt)("inlineCode",{parentName:"p"},"port"),"\u2014independent of\ntheir name."),(0,r.kt)("p",null,"To summarize, we have now seen three ways to query data, all based on\ninformation that is intrinsic to the data. There's another way to write queries\nusing extrinsic information: ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/data-model/taxonomies"},"event taxonomies"),", which define\n",(0,r.kt)("em",{parentName:"p"},"concepts")," and ",(0,r.kt)("em",{parentName:"p"},"models"),". Concepts are basically field mappings that VAST\nresolves prior to query execution, whereas models define a tuple over concepts,\ne.g., to represent common structures like a network connection 4-tuple. A\nconcept query looks syntactically identical to field extractor query. For\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"net.src.ip !in 192.168.0.0/16\n")),(0,r.kt)("p",null,"VAST resolves the concept ",(0,r.kt)("inlineCode",{parentName:"p"},"net.src.ip")," to all fieldnames that this concept has\nbeen defined with. We defer to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/data-model/taxonomies"},"taxonomy documentation")," for a\nmore detailed discussion."),(0,r.kt)("h2",{id:"choose-an-export-format"},"Choose an export format"),(0,r.kt)("p",null,"After your have written your query expression, the final step is selecting how\nyou'd like the result to be served. The ",(0,r.kt)("inlineCode",{parentName:"p"},"export")," command spins up a VAST client\nthat connects to a server where the query runs, and receives the results back to\nthen render them on standard output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"vast export [options] <format> [options] [expr]\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats"},"format")," defines how VAST renders the query\nresults. Text formats include ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/json"},"JSON"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/csv"},"CSV"),", or tool-specific data encodings like\n",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/zeek"},"Zeek"),". ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/pcap"},"PCAP")," is\nan example for a binary format."),(0,r.kt)("p",null,"For example, to run query that exports the results as JSON, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"vast export json net.src.ip in 10.0.0.0/8\n")))}d.isMDXComponent=!0},50202:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/extractors.dark-81d211436843a955f586bda89f6f9eb5.png"},96435:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/extractors.light-a416e40b9bb999ae6ac6c003da6681e3.png"}}]);