"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3236],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),l=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=l(a),u=r,h=c["".concat(p,".").concat(u)]||c[u]||d[u]||o;return a?n.createElement(h,s(s({ref:t},m),{},{components:a})):n.createElement(h,s({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=u;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},36813:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=a(87462),r=(a(67294),a(3905));const o={},s="Ingest",i={unversionedId:"use/ingest/README",id:"use/ingest/README",title:"Ingest",description:"Ingesting data to VAST (aka importing) involves spinning up a VAST client",source:"@site/docs/use/ingest/README.md",sourceDirName:"use/ingest",slug:"/use/ingest/",permalink:"/docs/use/ingest/",draft:!1,editUrl:"https://github.com/tenzir/vast/tree/master/web/docs/use/ingest/README.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Run",permalink:"/docs/use/run/"},next:{title:"Query",permalink:"/docs/use/query/"}},p={},l=[{value:"Choose an import format",id:"choose-an-import-format",level:2},{value:"Discard events from a data source",id:"discard-events-from-a-data-source",level:2},{value:"Infer a schema automatically",id:"infer-a-schema-automatically",level:2},{value:"Write a schema manually",id:"write-a-schema-manually",level:2},{value:"Map events to schemas",id:"map-events-to-schemas",level:2}],m={toc:l},c="wrapper";function d(e){let{components:t,...o}=e;return(0,r.kt)(c,(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"ingest"},"Ingest"),(0,r.kt)("p",null,"Ingesting data to VAST (aka ",(0,r.kt)("em",{parentName:"p"},"importing"),") involves spinning up a VAST client\nthat parses and ships the data to a VAST server. In the following, we assume\nthat you ",(0,r.kt)("a",{parentName:"p",href:"/docs/use/run"},"set up a server")," listening at ",(0,r.kt)("inlineCode",{parentName:"p"},"localhost:42000"),"."),(0,r.kt)("h2",{id:"choose-an-import-format"},"Choose an import format"),(0,r.kt)("p",null,"Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," command to ingest data from standard input or file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"vast import [options] <format> [options] [expr]\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats"},"format")," defines the encoding of data. Text\nformats include ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/json"},"JSON"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/csv"},"CSV"),", or tool-specific data encodings like\n",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/zeek"},"Zeek"),". Examples for binary formats are\n",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/pcap"},"PCAP")," and\n",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/netflow"},"NetFlow"),"."),(0,r.kt)("p",null,"For example, to import a file in JSON, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," format:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"vast import json < data.json\n")),(0,r.kt)("h2",{id:"discard-events-from-a-data-source"},"Discard events from a data source"),(0,r.kt)("p",null,"To reduce the volume of a data source or to filter out unwanted content, you can\nprovide a filter expression to the ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," command."),(0,r.kt)("p",null,"For example, you might want to import ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/formats/suricata"},"Suricata EVE\nJSON"),", but skip over all ",(0,r.kt)("inlineCode",{parentName:"p"},"suricata.stats"),"\nevents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"vast import suricata '#type != \"suricata.stats\"' < path/to/eve.json\n")),(0,r.kt)("p",null,"See the ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/query-language/"},"query language documentation")," to\nlearn more about how to write filter expressions."),(0,r.kt)("h2",{id:"infer-a-schema-automatically"},"Infer a schema automatically"),(0,r.kt)("admonition",{title:"Auto-inference coming soon",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Writing a schema will be optional in the future. For example, only when you want\nto tune the data semantics. Take a look at the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tenzir/public-roadmap/issues/5"},"corresponding roadmap\nitem")," to better understand\nwhen this capability lands in VAST.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"infer")," command attempts to deduce a schema, given a sample of data. For\nexample, consider this JSON data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "timestamp": "2011-08-14T07:38:53.914038+0200",\n  "src_ip": "147.32.84.165",\n  "src_port": 138,\n  "dest_ip": "147.32.84.255",\n  "dest_port": 138,\n  "proto": "UDP"\n}\n')),(0,r.kt)("p",null,"To infer its schema, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"jq -c < data.json | head -1 | vast infer\n")),(0,r.kt)("p",null,"This prints:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"type json = record {timestamp: time, src_ip: ip, src_port: int64, dest_ip: ip, dest_port: int, proto: string}\n")),(0,r.kt)("admonition",{title:"YAML Modules coming soon",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"We are currently reworking VAST's schema language. The available\n",(0,r.kt)("a",{parentName:"p",href:"/docs/use/introspect"},"introspection capabilities")," already show the new schema\nstyle. Track the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tenzir/public-roadmap/issues/15"},"corresponding roadmap\nitem")," to see when this\nrewrite lands.")),(0,r.kt)("p",null,"The idea is that ",(0,r.kt)("inlineCode",{parentName:"p"},"infer")," jump-starts the schema writing process by providing a\nreasonable blueprint. You still need to provide the right name for the type and\nperform adjustments, such as replacing some generic types with more semantic\naliases, e.g., using the ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp")," alias instead of type ",(0,r.kt)("inlineCode",{parentName:"p"},"time")," to designate\nthe event timestamp."),(0,r.kt)("h2",{id:"write-a-schema-manually"},"Write a schema manually"),(0,r.kt)("p",null,"If VAST does not ship with a ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/data-model/modules"},"module")," for your data out of the box,\nor the inference is not good enough for your use case regarding type semantics\nor performance, you can easily write one yourself."),(0,r.kt)("p",null,"A schema is a record type with a name so that VAST can\nrepresent it as a table internally. You would write a schema manually or extend\nan existing schema if your goal is tuning type semantics and performance. For\nexample, if you have a field of type ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," that only holds IP addresses, you\ncan upgrade it to type ",(0,r.kt)("inlineCode",{parentName:"p"},"addr")," and enjoy the benefits of richer query\nexpressions, e.g., top-k prefix search. Or if you onboard a new data source, you\ncan ship a schema along with ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/data-model/taxonomies#concepts"},"concept")," mappings for a deeper\nintegration."),(0,r.kt)("p",null,"You write a schema (and potentially accompanying types, concepts, and models) in\na ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/data-model/modules"},"module"),"."),(0,r.kt)("p",null,"Let's write one from scratch, for a tiny dummy data source called ",(0,r.kt)("em",{parentName:"p"},"foo")," that\nproduces CSV events of this shape:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csv"},"date,target,message\n2022-05-17,10.0.0.1,foo\n2022-05-18,10.0.0.2,bar\n2022-05-18,10.0.0.3,bar\n")),(0,r.kt)("p",null,"The corresponding schema type looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"message:\n  record:\n    - date: time\n    - target: ip\n    - message: msg\n")),(0,r.kt)("p",null,"You can embed this type definition in a dedicated ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"module: foo\ntypes:\n  message:\n    record:\n      - date: time\n      - target: ip\n      - message: msg\n")),(0,r.kt)("p",null,"Now that you have a new module, you can choose to deploy it at the client or\nthe server. When a VAST server starts, it will send a copy of its local schemas\nto the client. If the client has a schema for the same type, it will override\nthe server version. We recommend deploying the module at the server when all\nclients should see the contained schemas, and at the client when the scope is\nlocal. The diagram below illustrates the initial handshake:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Schema Transfer",src:a(91463).Z+"#gh-light-mode-only",width:"1448",height:"486"}),"\n",(0,r.kt)("img",{alt:"Schema Transfer",src:a(68189).Z+"#gh-dark-mode-only",width:"1448",height:"486"})),(0,r.kt)("p",null,"Regardless of where you deploy the module, the procedure is the same at client\nand server: place the module in an existing module directory, such as\n",(0,r.kt)("inlineCode",{parentName:"p"},"/etc/vast/modules"),", or tell VAST in your ",(0,r.kt)("inlineCode",{parentName:"p"},"vast.yaml")," configuration file where\nto look for additional modules via the ",(0,r.kt)("inlineCode",{parentName:"p"},"module-dirs")," key:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"vast:\n  module-dirs:\n    - path/to/modules\n")),(0,r.kt)("p",null,"At the server, restart VAST and you're ready to go. Or just spin up a new client\nand ingest the CSV with richer typing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"vast import csv < foo.csv\n")),(0,r.kt)("h2",{id:"map-events-to-schemas"},"Map events to schemas"),(0,r.kt)("p",null,"For some input formats, such as JSON and CSV, VAST requires an existing schema\nto find the corresponding type definition and use higher-level types."),(0,r.kt)("p",null,"There exist two ways to tell VAST how to map events to schemas:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Field Matching"),": by default, VAST checks every new record whether there\nexists a corresponding schema where the record fields match. If found, VAST\nautomatically assigns the matching schema."),(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"--type=PREFIX"),' option makes it possible to restrict the set of candidate\nschemas to type names with a given prefix, in case there exist multiple\nschemas with identical field names. "Prefix" here means up to a dot delimiter\nor a full type name, e.g., ',(0,r.kt)("inlineCode",{parentName:"p"},"suricata")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"suricata.dns")," are valid prefixes,\nbut neither ",(0,r.kt)("inlineCode",{parentName:"p"},"suricat")," nor ",(0,r.kt)("inlineCode",{parentName:"p"},"suricata.d"),"."),(0,r.kt)("admonition",{parentName:"li",title:"Performance Boost",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"In case the prefix specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"--type")," yields ",(0,r.kt)("em",{parentName:"p"},"exactly one")," possible\ncandidate schema, VAST can operate substantially faster. The reason is that\nVAST disambiguates multiple schemas by comparing their normalized\nrepresentation, which works by computing hash of the list of sorted field\nnames and comparing it to the hash of the candidate types."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Selector Specification"),": some events have a dedicated field to indicate\nthe type name of a particular event. For example, Suricata EVE JSON records\nhave an ",(0,r.kt)("inlineCode",{parentName:"p"},"event_type")," field that contains ",(0,r.kt)("inlineCode",{parentName:"p"},"flow"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"dns"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"smb"),", etc., to\nsignal what object structure to expect."),(0,r.kt)("p",{parentName:"li"},"To designate a selector field, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"--selector=FIELD:PREFIX")," option to\nspecify a colon-separated field-name-to-schema-prefix mapping, e.g.,\n",(0,r.kt)("inlineCode",{parentName:"p"},"vast import json --selector=event_type:suricata")," reads the value from the\nfield ",(0,r.kt)("inlineCode",{parentName:"p"},"event_type")," and prefixes it with ",(0,r.kt)("inlineCode",{parentName:"p"},"suricata.")," to look for a\ncorresponding schema."))))}d.isMDXComponent=!0},68189:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/schema-transfer.dark-924e5529116843b98ce544e88e06718c.png"},91463:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/schema-transfer.light-374a21d62ac6eb9f0b663fa5a91d6bf5.png"}}]);