"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7429],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>g});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(a),u=r,g=m["".concat(p,".").concat(u)]||m[u]||c[u]||i;return a?n.createElement(g,o(o({ref:t},d),{},{components:a})):n.createElement(g,o({ref:t},d))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},76661:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(87462),r=(a(67294),a(3905));const i={title:"Richer Typing in Sigma",description:"Towards Native Sigma Rule Execution",authors:"mavam",date:new Date("2022-08-12T00:00:00.000Z"),last_updated:new Date("2023-02-08T00:00:00.000Z"),tags:["sigma","regex","query-frontend"]},o=void 0,l={permalink:"/blog/richer-typing-in-sigma",source:"@site/blog/richer-typing-in-sigma/index.md",title:"Richer Typing in Sigma",description:"Towards Native Sigma Rule Execution",date:"2022-08-12T00:00:00.000Z",formattedDate:"August 12, 2022",tags:[{label:"sigma",permalink:"/blog/tags/sigma"},{label:"regex",permalink:"/blog/tags/regex"},{label:"query-frontend",permalink:"/blog/tags/query-frontend"}],readingTime:4.72,hasTruncateMarker:!0,authors:[{name:"Matthias Vallentin",title:"Co-Founder & CEO",url:"https://github.com/mavam",email:"matthias@tenzir.com",imageURL:"https://github.com/mavam.png",key:"mavam"}],frontMatter:{title:"Richer Typing in Sigma",description:"Towards Native Sigma Rule Execution",authors:"mavam",date:"2022-08-12T00:00:00.000Z",last_updated:"2023-02-08T00:00:00.000Z",tags:["sigma","regex","query-frontend"]},prevItem:{title:"VAST v2.3",permalink:"/blog/vast-v2.3"},nextItem:{title:"VAST v2.2",permalink:"/blog/vast-v2.2"}},p={authorsImageUrls:[void 0]},s=[],d={toc:s},m="wrapper";function c(e){let{components:t,...i}=e;return(0,r.kt)(m,(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"VAST's ",(0,r.kt)("a",{parentName:"p",href:"/docs/understand/query-language/frontends/sigma"},"Sigma frontend"),"\nnow supports more modifiers. In the Sigma language, modifiers transform\npredicates in various ways, e.g., to apply a function over a value or to change\nthe operator of a predicate. Modifiers are the customization point to enhance\nexpressiveness of query operations."),(0,r.kt)("p",null,"The new ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/pySigma"},"pySigma")," effort, which will eventually replace the\nnow-considered-legacy ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/sigma"},"sigma")," project, comes with new modifiers as well.\nMost notably, ",(0,r.kt)("inlineCode",{parentName:"p"},"lt"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"lte"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"gt"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"gte")," provide comparisons over value domains\nwith a total ordering, e.g., numbers: ",(0,r.kt)("inlineCode",{parentName:"p"},"x >= 42"),". In addition, the ",(0,r.kt)("inlineCode",{parentName:"p"},"cidr"),"\nmodifier interprets a value as subnet, e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"10.0.0.0/8"),". Richer typing!"),(0,r.kt)("p",null,"How does the frontend work? Think of it as a parser that processes the YAML and\ntranslates it into an expression tree, where the leaves are predicates with\ntyped operands according to VAST's data model. Here's how it works:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Sigma Query Frontend",src:a(38522).Z+"#gh-light-mode-only",width:"999",height:"920"}),"\n",(0,r.kt)("img",{alt:"Sigma Query Frontend",src:a(49980).Z+"#gh-dark-mode-only",width:"999",height:"920"})),(0,r.kt)("p",null,"Let's take a closer look at some Sigma rule modifiers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"selection:\n  x|re: 'f(o+|u)'\n  x|lt: 42\n  x|cidr: 192.168.0.0/23\n  x|base64offset|contains: 'http://'\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"|")," symbol applies a modifier to a field. Let's walk through the above\nexample:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"re")," modifier changes the predicate operand from ",(0,r.kt)("inlineCode",{parentName:"p"},'x == "f(o+|u)"')," to\n",(0,r.kt)("inlineCode",{parentName:"p"},"x == /f(o+|u)/"),", i.e., the type of the right-hand side changes from ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),"\nto ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"lt")," modifier changes the predicate operator from ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", i.e.,\n",(0,r.kt)("inlineCode",{parentName:"p"},"x == 42")," becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"x < 42"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"cidr")," modifier changes the predicate operand to type subnet. In VAST,\nparsing the operand type into a subnet happens automatically, so the Sigma\nfrontend only changes the operator to ",(0,r.kt)("inlineCode",{parentName:"p"},"in"),". That is, ",(0,r.kt)("inlineCode",{parentName:"p"},'x == "192.168.0.0/23"'),"\nbecomes ",(0,r.kt)("inlineCode",{parentName:"p"},"x in 192.168.0.0/23"),". Since VAST supports top-k prefix search on\nsubnets natively, nothing else needs to be changed."),(0,r.kt)("p",{parentName:"li"},"Other backends expand this to:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-c"},'x == "192.168.0.*" || x == "192.168.1.*"\n')),(0,r.kt)("p",{parentName:"li"},"This expansion logic on strings doesn't scale very well: for a ",(0,r.kt)("inlineCode",{parentName:"p"},"/22"),", you\nwould have to double the number of predicates, and for a ",(0,r.kt)("inlineCode",{parentName:"p"},"/21")," quadruple\nthem. This is where rich and deep typing in the language pays off.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"x"),": there are two modifiers that operate in a chained fashion,\ntransforming the predicate in two steps:"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Initial: ",(0,r.kt)("inlineCode",{parentName:"li"},'x == "http://"')),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"base64offset"),": ",(0,r.kt)("inlineCode",{parentName:"li"},'x == "aHR0cDovL" || x == "h0dHA6Ly" || x == "odHRwOi8v"')),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"contains"),": ",(0,r.kt)("inlineCode",{parentName:"li"},'x in "aHR0cDovL" || x in "h0dHA6Ly" || x in "odHRwOi8v"'))),(0,r.kt)("p",{parentName:"li"},"First, ",(0,r.kt)("inlineCode",{parentName:"p"},"base64offset")," always expands a value into a disjunction of 3\npredicates, each of which performs an equality comparison to a\nBase64-transformed value.",(0,r.kt)("sup",{parentName:"p",id:"fnref-1-0b1adb"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1-0b1adb",className:"footnote-ref"},"1"))),(0,r.kt)("p",{parentName:"li"},"Thereafter, the ",(0,r.kt)("inlineCode",{parentName:"p"},"contains")," modifier translates the respective predicate\noperator from ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"in"),". Other Sigma backends that don't support substring\nsearch natively transform the value instead by wrapping it into ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),"\nwildcards, e.g., translate ",(0,r.kt)("inlineCode",{parentName:"p"},'"foo"')," into ",(0,r.kt)("inlineCode",{parentName:"p"},'"*foo*"'),"."))),(0,r.kt)("p",null,"Our ultimate goal is to support a fully function executional platform for Sigma\nrules. The table below shows the current implementation status of modifiers,\nwhere \u2705 means implemented, \ud83d\udea7 not yet implemented but possible, and \u274c not yet\nsupported by VAST's execution engine:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Modifier"),(0,r.kt)("th",{parentName:"tr",align:null},"Use"),(0,r.kt)("th",{parentName:"tr",align:"center"},"sigmac"),(0,r.kt)("th",{parentName:"tr",align:"center"},"VAST"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contains")),(0,r.kt)("td",{parentName:"tr",align:null},"perform a substring search with the value"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"startswith")),(0,r.kt)("td",{parentName:"tr",align:null},"match the value as a prefix"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"endswith")),(0,r.kt)("td",{parentName:"tr",align:null},"match the value as a suffix"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"base64")),(0,r.kt)("td",{parentName:"tr",align:null},"encode the value with Base64"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"base64offset")),(0,r.kt)("td",{parentName:"tr",align:null},"encode value as all three possible Base64 variants"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"utf16le"),"/",(0,r.kt)("inlineCode",{parentName:"td"},"wide")),(0,r.kt)("td",{parentName:"tr",align:null},"transform the value to UTF16 little endian"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\ud83d\udea7")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"utf16be")),(0,r.kt)("td",{parentName:"tr",align:null},"transform the value to UTF16 big endian"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\ud83d\udea7")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"utf16")),(0,r.kt)("td",{parentName:"tr",align:null},"transform the value to UTF16"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\ud83d\udea7")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"re")),(0,r.kt)("td",{parentName:"tr",align:null},"interpret the value as regular expression"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\ud83d\udea7")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"cidr")),(0,r.kt)("td",{parentName:"tr",align:null},"interpret the value as a IP CIDR"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"all")),(0,r.kt)("td",{parentName:"tr",align:null},"changes the expression logic from OR to AND"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lt")),(0,r.kt)("td",{parentName:"tr",align:null},"compare less than (",(0,r.kt)("inlineCode",{parentName:"td"},"<"),") the value"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lte")),(0,r.kt)("td",{parentName:"tr",align:null},"compare less than or equal to (",(0,r.kt)("inlineCode",{parentName:"td"},"<="),") the value"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"gt")),(0,r.kt)("td",{parentName:"tr",align:null},"compare greater than (",(0,r.kt)("inlineCode",{parentName:"td"},">"),") the value"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"gte")),(0,r.kt)("td",{parentName:"tr",align:null},"compare greater than or equal to (",(0,r.kt)("inlineCode",{parentName:"td"},">="),") the value"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expand")),(0,r.kt)("td",{parentName:"tr",align:null},"expand value to placeholder strings, e.g., ",(0,r.kt)("inlineCode",{parentName:"td"},"%something%")),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")))),(0,r.kt)("p",null,"Aside from completing the implementation of the missing modifiers, there are\nthree missing pieces for Sigma rule execution to become viable in VAST:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Regular expressions"),": VAST currently has no efficient mechanism to execute\nregular expressions. A regex lookup requires a full scan of the data.\nMoreover, the regular expression execution speed is abysimal. But we are\naware of it and are working on this soon. The good thing is that the\ncomplexity of regular expression execution over batches of data is\nmanageable, given that we would call into the corresponding ",(0,r.kt)("a",{parentName:"p",href:"https://arrow.apache.org/docs/cpp/compute.html#containment-tests"},"Arrow Compute\nfunction")," for the heavy lifting. The number one\nchallenge will be reduing the data to scan, because the Bloom-filter-like\nsketch data structures in the catalog cannot handle pattern types. If the\nsketches cannot identify a candidate set, all data needs to be scanned,"),(0,r.kt)("p",{parentName:"li"},'To alleviate the effects of full scans, it\'s possible to winnow down the\ncandidate set of partitions by executing rules periodically. When making the\nwindows asymptotically small, this yields effectively streaming execution,\nwhich VAST already supports in the form of "live queries".')),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Case-insensitive strings"),": All strings in Sigma rules are case-insensitive\nby default, but VAST's string search is case-sensitive. As a workaround, we\ncould translate Sigma strings into regular expressions, e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},'"Foo"')," into\n",(0,r.kt)("inlineCode",{parentName:"p"},"/Foo/i"),". Unfortunately there is a big performance gap between string\nequality search and regular expression search. We will need to find a better\nsolution for production-grade rule execution.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Field mappings"),": while Sigma rules execute already syntactically, VAST\ncurrently doesn't touch the field names in the rules and interprets them as\n",(0,r.kt)("a",{parentName:"p",href:"https://vast.io/docs/understand/query-language/expressions#field-extractor"},"field extractors"),". In other words, VAST doesn't support\nthe Sigma taxonomy yet. Until we provide the mappings, you can already write\ngeneric Sigma rules using ",(0,r.kt)("a",{parentName:"p",href:"https://vast.io/docs/understand/data-model/taxonomies#concepts"},"concepts"),"."))),(0,r.kt)("p",null,"Please don't hesitate to swing by our ",(0,r.kt)("a",{parentName:"p",href:"/discord"},"community chat"),"\nand talk with us if you are passionate about Sigma and other topics around open\ndetection and response."),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1-0b1adb"},"What happens under the hood is a padding a string with spaces. ",(0,r.kt)("a",{parentName:"li",href:"https://tech-en.netlify.app/articles/en513032/index.html"},"Anton\nKutepov's article")," illustrates how this works.",(0,r.kt)("a",{parentName:"li",href:"#fnref-1-0b1adb",className:"footnote-backref"},"\u21a9")))))}c.isMDXComponent=!0},49980:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sigma-query-frontend-dark-acef89819a48db63cc2f2a69240d4c8f.png"},38522:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sigma-query-frontend-light-fc9a55b6708af9fca88bef9f3a1fcdba.png"}}]);